#include <opencv2/core.hpp>
#include <opencv2/videoio.hpp>
#include <opencv2/highgui.hpp>
#include <opencv2/imgproc.hpp>
#include <iostream>
#include <stdio.h>
#include <ctime>
#include <chrono>
#include "tracker.hpp"
using namespace cv;
using namespace std;



// Get time stamp in microseconds.
uint64_t micros()
{
    uint64_t us = std::chrono::duration_cast<std::chrono::microseconds>(
            std::chrono::high_resolution_clock::now().time_since_epoch())
            .count();
    return us; 
}


int main(int, char**)
{
    tracker t = tracker();
    Mat frame;
    //--- INITIALIZE VIDEOCAPTURE
    // VideoCapture cap;
    // open the default camera using default API
    // cap.open(0);
    // OR advance usage: select any API backend
    int deviceID = 0;             // 0 = open default camera
    int apiID = cv::CAP_ANY;      // 0 = autodetect default API
    // open selected camera using selected API
    
    int to_corners[4][2] = {{0, 640}, {0, 0}, {480, 0}, {480, 640}};
    int from_corners[4][2] = {{5, 6}, {560, 8}, {518, 242}, {4, 277}};
    Point2f inQuad[4];
    Point2f outQuad[4];

    // 324 55
    // 418 45
    // 413 121
    // 324 132
    inQuad[0] = Point2f(324,55);
    inQuad[1] = Point2f(418,45);
    inQuad[2] = Point2f(413,121);
    inQuad[3] = Point2f(324,132); 
    int w = 640;
    int h = 480;
    outQuad[0] = Point2f(0,w);
    outQuad[1] = Point2f(0,0);
    outQuad[2] = Point2f(h,0);
    outQuad[3] = Point2f(h,w);
    int shift_int = 0;
    Scalar shift = Scalar(shift_int);
    Moments moms;


    Mat transform_matrix = getPerspectiveTransform(inQuad, outQuad);
    Size transformSize = Size(w,h);
    Mat transformed;
    Mat hsv;
    Mat bin;
    Scalar lowerb = Scalar(45,45,155);
    Scalar upperb = Scalar(65+shift_int,65,175);

    
    
    VideoCapture cap = VideoCapture("udp://10.42.0.124:5000?overrun_nonfatal=1&fifo_size=50000000");
    

    // cap.open(deviceID, apiID);
    // check if we succeeded
    if (!cap.isOpened()) {
        cerr << "ERROR! Unable to open camera\n";
        return -1;
    }
    //--- GRAB AND WRITE LOOP
    cout << "Start grabbing" << endl
        << "Press any key to terminate" << endl;
    for (;;)
    {
        // wait for a new frame from camera and store it into 'frame'
        
        cap.read(frame);
        uint64_t start_t;
        uint64_t end_t;
        start_t = micros();
        // check if we succeeded
        if (frame.empty()) {
            cerr << "ERROR! blank frame grabbed\n";
            break;
        }
        // show live and wait for a key with timeout long enough to show images

        // warpPerspective(frame, transformed, transform_matrix,transformSize);

        cvtColor(frame, hsv, COLOR_BGR2HSV);
        hsv += shift;
        inRange(hsv,lowerb, upperb,bin);



        moms = moments(bin);
        if (moms.m00>0){
            float x = 1.0*moms.m01/moms.m00;
            float y = 1.0*moms.m10/moms.m00; 
            float scale_fac = transform_matrix.at<uint8_t>(2,0)*x + transform_matrix.at<uint8_t>(2,1)*y + 1;
            float xt = (transform_matrix.at<uint8_t>(0,0)*x + transform_matrix.at<uint8_t>(0,1)*y + transform_matrix.at<uint8_t>(0,2))/scale_fac;  
            float yt = (transform_matrix.at<uint8_t>(1,0)*x + transform_matrix.at<uint8_t>(1,1)*y + transform_matrix.at<uint8_t>(1,2))/scale_fac;  
            cout << "x: " << x << "\n";
            cout << "y: " << y << "\n";
            cout << "xt: " << xt << "\n";
            cout << "yt: " << yt << "\n";

        }
        // inRange(hsv,l)

        end_t = micros();

        // cout << (end_t - start_t)/1000 << "\n";

        imshow("Live", bin);
        if (waitKey(1) >= 0)
            break;
    }
    // the camera will be deinitialized automatically in VideoCapture destructor
    return 0;
}